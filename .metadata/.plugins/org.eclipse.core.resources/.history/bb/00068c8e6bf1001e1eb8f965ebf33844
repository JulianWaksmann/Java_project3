package TP1_2048;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

//Interfaz funcional para representar el método a ejecutar en los observadores
@FunctionalInterface
interface AccionObservadorMotor {
 void ejecutar(IObservadorMotorJuego observador);
}


public class MotorJuego implements IMotorJuego, IObservadorUIJuego{
	
	int[][] tablero;
	int probabilidadDelDos;
	int tamanioTablero;
	private List<IObservadorMotorJuego> observadores;
	
	public MotorJuego() {
		observadores = new ArrayList<IObservadorMotorJuego>();
	}

	@Override
	public void NuevoJuego(int tamanioTablero, int probabilidadDelDos) {
		this.tamanioTablero = tamanioTablero;
		this.probabilidadDelDos = probabilidadDelDos;
		iniciarJuego();
		
	}

	@Override
	public void Mover(Direccion direccion) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void AgregarObservador(IObservadorMotorJuego observador) {
		observadores.add(observador);
	}

	@Override
	public void RemoverObservador(IObservadorMotorJuego observador) {
		observadores.remove(observador);
	}
	
	
	//metodos privados
	private void iniciarJuego()
	{
		//genera un nuevo tablero vacio
		tablero = new int[tamanioTablero][tamanioTablero];
		//avisa a los observadores que hay un nuevo tablero
		crearTablero(tablero);
		
		//Genera las primeras dos celdas
		
		//Primeera celda
		//obtiene una nueva celda para el inicio del juego
		Celda nuevaCelda = obtenerNuevaCelda();
		tablero[nuevaCelda.getY()][nuevaCelda.getX()] = nuevaCelda.getValor();
		
		//avisa a los observadores que hay un nuevo movimiento en el tablero
		PasoMovimiento pasoNuevaCelda = new PasoMovimiento(nuevaCelda, nuevaCelda);
		realizarPasoMovimiento(pasoNuevaCelda);
		
		//segunda celda
		nuevaCelda = obtenerNuevaCelda();
		tablero[nuevaCelda.getY()][nuevaCelda.getX()] = nuevaCelda.getValor();
		
		//avisa a los observadores que hay un nuevo movimiento en el tablero
		pasoNuevaCelda = new PasoMovimiento(nuevaCelda, nuevaCelda);
		realizarPasoMovimiento(pasoNuevaCelda);

	}
	
	//obtener una nueva celda
	private Celda obtenerNuevaCelda() {
		final Random random = new Random();
		
		Celda celdaLibre = null;
		
		List<Integer> celdasLibres = obtenerCeldasLibres();
		
		if (celdasLibres.size() > 0) {
			int index = random.nextInt(celdasLibres.size());
			int nroCeldaLibre = celdasLibres.get(index);
			int valor = obtenernuevoValorCelda();
			celdaLibre = new Celda(nroCeldaLibre / this.tamanioTablero, nroCeldaLibre % this.tamanioTablero, valor);
		}
		return celdaLibre;
	}
	
	private boolean celdaOcupada(int x, int y) {
		return this.tablero[y][x] != 0;
	}
	
	private boolean celdaVacia(int x, int y) {
		return !celdaOcupada(x, y);
	}
	
	/******************************************************
	* Las celdas estan numeradas con la siguiente formula *
	* nroCelda = coordenadaY*tamanioTablero+coordenadaX   *
	* *****************************************************/
	private List<Integer> obtenerCeldasLibres() {
		List<Integer> celdasVacias = new ArrayList<Integer>();
		for(int y = 0; y < this.tamanioTablero; y ++) {
			for (int x = 0; x < this.tamanioTablero; x++) {
				if (celdaVacia(x, y)) {
					celdasVacias.add(y * this.tamanioTablero + x);
				}
			}
		}
		return celdasVacias;
	}
	
	private int obtenernuevoValorCelda() {
		final Random random = new Random();

		//numero aleatorio entre 1 y 100
		int numeroAleatorio = random.nextInt(100) + 1;

        if (numeroAleatorio <= this.probabilidadDelDos) {
            return 2;
        } else {
            return 4;
        }
	}
	
	 
	
	
	
	
	
	/*********************************************
	 * Metodos genericos de llamada a observador *
	 *********************************************/
	// Ejecutar una acción en todos los observadores utilizando reflection
    public void ejecutarEnObservadores(String nombreMetodo, Object... args) {
        for (IObservadorMotorJuego observador : observadores) {
            try {
                Method metodo = IObservadorMotorJuego.class.getMethod(nombreMetodo, obtenerTiposArgumentos(args));
                metodo.invoke(observador, args);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    // Obtener los tipos de los argumentos
    private Class<?>[] obtenerTiposArgumentos(Object... args) {
        Class<?>[] tipos = new Class[args.length];
        for (int i = 0; i < args.length; i++) {
            tipos[i] = args[i].getClass();
        }
        return tipos;
    }

    // Ejecutar una acción en todos los observadores
    public void ejecutarEnObservadores(AccionObservadorMotor accion) {
        for (IObservadorMotorJuego observador : observadores) {
            accion.ejecutar(observador);
        }
    }
    
 // Crear tablero en todos los observadores
    public void crearTablero(int[][] tablero) {
        ejecutarEnObservadores(observador -> observador.CrearTablero(tablero));
    }

    // Realizar paso de movimiento en todos los observadores
    public void realizarPasoMovimiento(PasoMovimiento movimiento) {
        ejecutarEnObservadores(observador -> observador.RealizarPasoMovimiento(movimiento));
    }

    // Actualizar puntos en todos los observadores
    public void actualizarPuntos(int puntos) {
        ejecutarEnObservadores(observador -> observador.ActualizarPuntos(puntos));
    }

    // Indicar que se perdio en todos los observadores
    public void perdio() {
        ejecutarEnObservadores(observador -> observador.Perdio());
    }

    // Indicar que se gano en todos los observadores
    public void gano() {
        ejecutarEnObservadores(observador -> observador.Gano());
    }

}

